{"version":3,"file":"nanopop.umd.js","sources":["../src/index.ts"],"sourcesContent":["type Direction = 'top' | 'left' | 'bottom' | 'right';\ntype Alignment = 'start' | 'middle' | 'end';\n\nexport type VariantFlipOrder = {\n    start: string;\n    middle: string;\n    end: string;\n};\n\nexport type PositionFlipOrder = {\n    top: string;\n    right: string;\n    bottom: string;\n    left: string;\n};\n\nexport type NanoPopPosition = `${Direction}-${Alignment}` | Direction;\n\nexport type NanoPopOptions = {\n    container: DOMRect;\n    position: NanoPopPosition;\n    variantFlipOrder: VariantFlipOrder;\n    positionFlipOrder: PositionFlipOrder;\n    margin: number;\n    reference?: HTMLElement;\n    popper?: HTMLElement;\n    arrow?: HTMLElement;\n    padding?: number;\n};\n\ntype AvailablePositions = {\n    t: number;\n    b: number;\n    l: number;\n    r: number;\n};\n\ntype AvailableVariants = {\n    vs: number;\n    vm: number;\n    ve: number;\n    hs: number;\n    hm: number;\n    he: number;\n};\n\ntype PositionPairs = [Direction, Direction];\n\nexport type PositionMatch = 'ts' | 'tm' | 'te' | 'bs' | 'bm' | 'be' | 'ls' | 'lm' | 'le' | 'rs' | 'rm' | 're';\n\nexport interface NanoPop {\n    update(updatedOptions?: Partial<NanoPopOptions>): PositionMatch | null;\n}\n\nexport interface NanoPopConstructor {\n\n    /**\n     * @param reference Reference element\n     * @param popper Actual popper element\n     * @param options Optional options\n     */\n    (reference: HTMLElement, popper: HTMLElement, options?: Partial<NanoPopOptions>): NanoPop;\n\n    /**\n     * @param options Partial options which get merged with the current one\n     */\n    (options?: Partial<NanoPopOptions>): NanoPop;\n}\n\n// Export current version\nexport const version = VERSION;\n\n// Export default\nexport const defaults = {\n    variantFlipOrder: {start: 'sme', middle: 'mse', end: 'ems'},\n    positionFlipOrder: {top: 'tbrl', right: 'rltb', bottom: 'btrl', left: 'lrbt'},\n    position: 'bottom',\n    margin: 8,\n    padding: 0\n};\n\n/**\n * Repositions an element once using the provided options and elements.\n * @param reference Reference element\n * @param popper Popper element\n * @param opt Optional, additional options\n */\nexport const reposition = (\n    reference: HTMLElement,\n    popper: HTMLElement,\n    opt?: Partial<NanoPopOptions>\n): PositionMatch | null => {\n    const {\n        container,\n        arrow,\n        margin,\n        padding,\n        position,\n        variantFlipOrder,\n        positionFlipOrder\n    } = {\n        container: document.documentElement.getBoundingClientRect(),\n        ...defaults,\n        ...opt\n    };\n\n    /**\n     * Reset position to resolve viewport\n     * See https://developer.mozilla.org/en-US/docs/Web/CSS/position#fixed\n     */\n    const {left: originalLeft, top: originalTop} = popper.style;\n    popper.style.left = '0';\n    popper.style.top = '0';\n\n    const refBox = reference.getBoundingClientRect();\n    const popBox = popper.getBoundingClientRect();\n\n    /**\n     * Holds coordinates of top, left, bottom and right alignment\n     */\n    const positionStore: AvailablePositions = {\n        t: refBox.top - popBox.height - margin,\n        b: refBox.bottom + margin,\n        r: refBox.right + margin,\n        l: refBox.left - popBox.width - margin\n    };\n\n    /**\n     * Holds corresponding variants (start, middle, end).\n     * The values depend on horizontal / vertical orientation\n     */\n    const variantStore: AvailableVariants = {\n        vs: refBox.left,\n        vm: refBox.left + refBox.width / 2 - popBox.width / 2,\n        ve: refBox.left + refBox.width - popBox.width,\n        hs: refBox.top,\n        hm: refBox.bottom - refBox.height / 2 - popBox.height / 2,\n        he: refBox.bottom - popBox.height\n    };\n\n    // Extract position and variant\n    // Top-start -> top is \"position\" and \"start\" is the variant\n    const [posKey, varKey = 'middle'] = position.split('-');\n    const positions = positionFlipOrder[posKey as keyof PositionFlipOrder];\n    const variants = variantFlipOrder[varKey as keyof VariantFlipOrder];\n\n    // Try out all possible combinations, starting with the preferred one.\n    const {top, left, bottom, right} = container;\n\n    for (const p of positions) {\n        const vertical = (p === 't' || p === 'b');\n\n        // The position-value\n        let positionVal = positionStore[p as keyof AvailablePositions];\n\n        // Which property has to be changes.\n        const [positionKey, variantKey] = (vertical ? ['top', 'left'] : ['left', 'top']) as PositionPairs;\n\n        /**\n         * box refers to the size of the popper element. Depending on the orientation this is width or height.\n         * The limit is the corresponding, maximum value for this position.\n         */\n        const [positionSize, variantSize] = vertical ? [popBox.height, popBox.width] : [popBox.width, popBox.height];\n\n        const [positionMaximum, variantMaximum] = vertical ? [bottom, right] : [right, bottom];\n        const [positionMinimum, variantMinimum] = vertical ? [top, left] : [left, top];\n\n        // Skip pre-clipped values\n        if (positionVal < positionMinimum || (positionVal + positionSize + padding) > positionMaximum) {\n            continue;\n        }\n\n        for (const v of variants) {\n\n            // The position-value, the related size value of the popper and the limit\n            let variantVal = variantStore[((vertical ? 'v' : 'h') + v) as keyof AvailableVariants];\n\n            if (variantVal < variantMinimum || (variantVal + variantSize + padding) > variantMaximum) {\n                continue;\n            }\n\n            // Subtract popBox's initial position\n            variantVal -= popBox[variantKey];\n            positionVal -= popBox[positionKey];\n\n            // Apply styles and normalize viewport\n            popper.style[variantKey] = `${variantVal}px`;\n            popper.style[positionKey] = `${positionVal}px`;\n\n            if (arrow) {\n                // Calculate refBox's center offset from its variant position for arrow positioning\n                const refBoxCenterOffset = vertical ? refBox.width / 2 : refBox.height / 2;\n\n                // When refBox is larger than popBox, have the arrow's variant position be the center of popBox instead.\n                const arrowVariantVal = refBoxCenterOffset * 2 < variantSize ?\n                    refBox[variantKey] + refBoxCenterOffset : variantVal + variantSize / 2;\n\n                // Arrow position is either on one side of the popBox or the other.\n                if (positionVal < refBox[positionKey]) {\n                    positionVal += positionSize;\n                }\n\n                // Apply styles to arrow\n                arrow.style[variantKey] = `${arrowVariantVal}px`;\n                arrow.style[positionKey] = `${positionVal}px`;\n            }\n\n            return (p + v) as PositionMatch;\n        }\n    }\n\n    // Revert style values (won't work with styled-elements or similar systems)\n    // \"Fix\" for https://github.com/Simonwep/nanopop/issues/7\n    popper.style.left = originalLeft;\n    popper.style.top = originalTop;\n\n    return null;\n};\n\n/**\n * Creates a stateful popper.\n * You can either...\n * ... pass an options object: createPopper(<options>)\n * ... pass both the reference and popper: create(<ref>, <el>, <?options>)\n * ... pass nothing, in this case you'll have to set at least both a reference and a popper in update.\n *\n * @param reference | options Reference element or options\n * @param popper Popper element\n * @param options Optional additional options\n */\nexport const createPopper: NanoPopConstructor = (\n    reference?: HTMLElement | Partial<NanoPopOptions>,\n    popper?: HTMLElement,\n    options?: Partial<NanoPopOptions>\n): NanoPop => {\n\n    // Resolve options\n    const baseOptions: Partial<NanoPopOptions> = typeof reference === 'object' && !(reference instanceof HTMLElement) ?\n        reference : {reference, popper, ...options};\n\n    return {\n\n        /**\n         * Repositions the current popper.\n         * @param options Optional options which get merged with the current ones.\n         */\n        update(options: Partial<NanoPopOptions> = baseOptions): PositionMatch | null {\n            const {reference, popper} = Object.assign(baseOptions, options);\n\n            if (!popper || !reference) {\n                throw new Error('Popper- or reference-element missing.');\n            }\n\n            return reposition(reference, popper, baseOptions);\n        }\n    };\n};\n"],"names":["version","defaults","reposition","reference","popper","opt","container","arrow","margin","padding","position","variantFlipOrder","positionFlipOrder","originalLeft","originalTop","refBox","popBox","positionStore","variantStore","posKey","varKey","positions","variants","top","left","bottom","right","p","vertical","positionVal","positionKey","variantKey","positionSize","variantSize","positionMaximum","variantMaximum","positionMinimum","variantMinimum","v","variantVal","refBoxCenterOffset","arrowVariantVal","createPopper","options","baseOptions"],"mappings":"+NAsEa,MAAAA,EAAU,QAGVC,EAAW,CACpB,iBAAkB,CAAC,MAAO,MAAO,OAAQ,MAAO,IAAK,KAAK,EAC1D,kBAAmB,CAAC,IAAK,OAAQ,MAAO,OAAQ,OAAQ,OAAQ,KAAM,MAAM,EAC5E,SAAU,SACV,OAAQ,EACR,QAAS,CACb,EAQaC,EAAa,CACtBC,EACAC,EACAC,IACuB,CACjB,KAAA,CACF,UAAAC,EACA,MAAAC,EACA,OAAAC,EACA,QAAAC,EACA,SAAAC,EACA,iBAAAC,EACA,kBAAAC,CAAA,EACA,CACA,UAAW,SAAS,gBAAgB,sBAAsB,EAC1D,GAAGX,EACH,GAAGI,CAAA,EAOD,CAAC,KAAMQ,EAAc,IAAKC,GAAeV,EAAO,MACtDA,EAAO,MAAM,KAAO,IACpBA,EAAO,MAAM,IAAM,IAEb,MAAAW,EAASZ,EAAU,wBACnBa,EAASZ,EAAO,wBAKhBa,EAAoC,CACtC,EAAGF,EAAO,IAAMC,EAAO,OAASR,EAChC,EAAGO,EAAO,OAASP,EACnB,EAAGO,EAAO,MAAQP,EAClB,EAAGO,EAAO,KAAOC,EAAO,MAAQR,CAAA,EAO9BU,EAAkC,CACpC,GAAIH,EAAO,KACX,GAAIA,EAAO,KAAOA,EAAO,MAAQ,EAAIC,EAAO,MAAQ,EACpD,GAAID,EAAO,KAAOA,EAAO,MAAQC,EAAO,MACxC,GAAID,EAAO,IACX,GAAIA,EAAO,OAASA,EAAO,OAAS,EAAIC,EAAO,OAAS,EACxD,GAAID,EAAO,OAASC,EAAO,MAAA,EAKzB,CAACG,EAAQC,EAAS,QAAQ,EAAIV,EAAS,MAAM,GAAG,EAChDW,EAAYT,EAAkBO,CAAiC,EAC/DG,EAAWX,EAAiBS,CAAgC,EAG5D,CAAC,IAAAG,EAAK,KAAAC,EAAM,OAAAC,EAAQ,MAAAC,GAASpB,EAEnC,UAAWqB,KAAKN,EAAW,CACjB,MAAAO,EAAYD,IAAM,KAAOA,IAAM,IAGjC,IAAAE,EAAcZ,EAAcU,CAA6B,EAGvD,KAAA,CAACG,EAAaC,CAAU,EAAKH,EAAW,CAAC,MAAO,MAAM,EAAI,CAAC,OAAQ,KAAK,EAMxE,CAACI,EAAcC,CAAW,EAAIL,EAAW,CAACZ,EAAO,OAAQA,EAAO,KAAK,EAAI,CAACA,EAAO,MAAOA,EAAO,MAAM,EAErG,CAACkB,EAAiBC,CAAc,EAAIP,EAAW,CAACH,EAAQC,CAAK,EAAI,CAACA,EAAOD,CAAM,EAC/E,CAACW,EAAiBC,CAAc,EAAIT,EAAW,CAACL,EAAKC,CAAI,EAAI,CAACA,EAAMD,CAAG,EAG7E,GAAI,EAAAM,EAAcO,GAAoBP,EAAcG,EAAevB,EAAWyB,GAI9E,UAAWI,KAAKhB,EAAU,CAGtB,IAAIiB,EAAarB,GAAeU,EAAW,IAAM,KAAOU,CAA6B,EAErF,GAAI,EAAAC,EAAaF,GAAmBE,EAAaN,EAAcxB,EAAW0B,GAY1E,IAPAI,GAAcvB,EAAOe,CAAU,EAC/BF,GAAeb,EAAOc,CAAW,EAG1B1B,EAAA,MAAM2B,CAAU,EAAI,GAAGQ,MACvBnC,EAAA,MAAM0B,CAAW,EAAI,GAAGD,MAE3BtB,EAAO,CAEP,MAAMiC,EAAqBZ,EAAWb,EAAO,MAAQ,EAAIA,EAAO,OAAS,EAGnE0B,EAAkBD,EAAqB,EAAIP,EAC7ClB,EAAOgB,CAAU,EAAIS,EAAqBD,EAAaN,EAAc,EAGrEJ,EAAcd,EAAOe,CAAW,IACjBD,GAAAG,GAIbzB,EAAA,MAAMwB,CAAU,EAAI,GAAGU,MACvBlC,EAAA,MAAMuB,CAAW,EAAI,GAAGD,MAGlC,OAAQF,EAAIW,IAMpB,OAAAlC,EAAO,MAAM,KAAOS,EACpBT,EAAO,MAAM,IAAMU,EAEZ,IACX,EAaa4B,EAAmC,CAC5CvC,EACAC,EACAuC,IACU,CAGV,MAAMC,EAAuC,OAAOzC,GAAc,UAAY,EAAEA,aAAqB,aACjGA,EAAY,CAAC,UAAAA,EAAW,OAAAC,EAAQ,GAAGuC,CAAO,EAEvC,MAAA,CAMH,OAAOA,EAAmCC,EAAmC,CACnE,KAAA,CAAC,UAAAzC,EAAW,OAAAC,GAAU,OAAO,OAAOwC,EAAaD,CAAO,EAE1D,GAAA,CAACvC,GAAU,CAACD,EACN,MAAA,IAAI,MAAM,uCAAuC,EAGpD,OAAAD,EAAWC,EAAWC,EAAQwC,CAAW,CACpD,CAAA,CAER"}